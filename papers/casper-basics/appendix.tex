\appendix
\clearpage


\section{Code for valid\_prepares and valid\_commits}

\begin{lstlisting}[language=Python, caption={Algorithm for counting up the prepare portion behind a checkpoint. \todo{fill this in}}, captionpos=b, label={alg:validprepare}]

def valid_prepares(checkpoint_source, epoch_source, checkpoint, epoch, d):
    
    # code goes here
    
    return z

\end{lstlisting}



\begin{lstlisting}[language=Python, caption={Algorithm for counting up the commit portion behind a checkpoint. \todo{fill this in} }, captionpos=b, label={alg:validprepare}]

def valid_commits(checkpoint, epoch, d):
    
    # code goes here
    
    return z

\end{lstlisting}

\section{Unused text}

\todo{This is where text goes that for which a home hasn't been found yet.  If no home is found, it will be deleted.}



We define an \textit{epoch} as a range of 100 blocks (e.g., blocks 600...699 are epoch 6), and a \textit{checkpoint} of an epoch is the final block in that epoch. 

The proposal mechanism will initially be the existing Ethereum proof of work chain, making the first version of Casper a \textit{hybrid PoW/PoS algorithm} that relies on proof of work for liveness but not safety, but in future versions the proposal mechanism can be substituted with something else.



for the same \epoch and \hash as in \eqref{eq:msgPREPARE}.  The $\hash$ is the block hash of the block at the start of the epoch.  A hash $\hash$ being justified entails that all fresh (non-finalized) ancestor blocks are also justified.  A hash $\hash$ being finalized entails that all ancestor blocks are also finalized, regardless of whether they were previously fresh or justified.  An ``ideal execution'' of the protocol is one where, at the start of every epoch, every validator Prepares and Commits the first blockhash of each epoch, specifying the same $\epochsource$ and $\hashsource$.

In the Casper protocol, there exists a set of validators, and in each \textit{epoch} (see below) validators may send two kinds of messages: $$[PREPARE, epoch, hash, epoch_{source}, hash_{source}]$$ and $$[COMMIT, epoch, hash]$$


If, during an epoch $e$, for some specific ancestry hash $h$, for any specific ($epoch_{source}, hash_{source}$ pair), there exist $\frac{2}{3}$ prepares of the form $$[PREPARE, e, h, epoch_{source}, hash_{source}]$$, then $h$ is considered \textit{justified}. If $\frac{2}{3}$ commits are sent of the form $$[COMMIT, e, h]$$ then $h$ is considered \textit{finalized}.


During epoch $n$, validators are expected to send prepare and commit messages with $\epoch = n$ and $h$ equal to a checkpoint of epoch $n$. Prepare messages may specify as \hashsource a checkpoint for any previous epoch (preferably the preceding checkpoint) of \hash, and which is \textit{justified} (see below), and the \epochsource is expected to be the epoch of that checkpoint.


Honest validators will never violate slashing conditions, so this implies the usual Byzantine fault tolerance safety property, but expressing this in terms of slashing conditions means that we are actually proving a stronger claim: if two conflicting checkpoints get finalized, then at least $\frac{1}{3}$ of validators were malicious, \textit{and we know whom to blame, and so we can maximally penalize them in order to make such faults expensive}.


This simplifies our finalty mechanism because it allows it to be expressed as a fork choice rule where the ``score'' of a block only depends on the block and its children, putting it into a similar category as more traditional PoW-based fork choice rules such as the longest chain rule and GHOST\cite{sompolinsky2013accelerating}.

Unlike GHOST, however, this fork choice rule is also \textit{finality-bearing}: there exists a ``finality'' mechanism that has the property that (i) the fork choice rule always prefers Finalized blocks over non-Finalized blocks, and

\begin{enumerate}
\item Start with HEAD equal to the genesis of the chain.
\item Select the descendant checkpoint of HEAD with the most commits (only Justified checkpoints are admissible)
\item Repeat (2) until no descendant with commits exists.
\item Choose the longest proof of work chain from there.
\end{enumerate}


The mechanism described above ensures \textit{plausible liveness}; however, it by itself does not ensure \textit{actual liveness}---that is, while the mechanism cannot get stuck in the strict sense, it could still enter a scenario where the proposal mechanism (e.g., the proof of work chain) gets into a state where it never ends up creating a checkpoint that could get Finalized.


The symmetry is as follows. In GHOST, a node starts with the head at the genesis, then begins to move forward down the chain, and if it encounters a block with multiple children then it chooses the child that has the larger quantity of work built on top of it (including the child block itself and its descendants).

In this algorithm, we follow a similar approach, except we repeatedly seek the child that comes the closest to achieving finality. Commits on a descendant are implicitly commits on all of its lineage, and so if a given descendant of a given block has more commits than any other descendant, then we know that all children along the chain from the head to this descendant are closer to finality than any of their siblings; hence, looking for the \textit{descendant} with the most commits and not just the \textit{child} replicates the GHOST principle most faithfully. 

(that is, the checkpoint of epoch \epoch must be Finalized during epoch \epoch, and the chain must learn about this before epoch \epoch ends). In simpler terms, when a user sends a ``deposit'' transaction, they need to wait for the transaction to be perfectly Finalized, and then they need to wait again for the next epoch to be Finalized; after this, they become part of the validator set.

In fact, when \textit{any} checkpoint gets $k > \frac{1}{3}$ commits, no conflicting checkpoint can get Finalized without $k - \frac{1}{3}$ of validators getting slashed. 


\begin{equation}
    \mathcal{D}(k) \equiv \begin{cases}
     \left\{ c \in \mathbf{C} : \mathbf{P}_k < c \right\} \qquad \qquad \qquad \!\! \textnormal{if $k = |\mathbf{P}| - 1$,} \\
         \left\{ c \in \mathbf{C} : \mathbf{P}_k < c \leq \mathbf{P}_{k+1} \right\} \qquad \textnormal{otherwise.} \\
     \end{cases}
\end{equation}

So using the example above, $\mathcal{D}(1) = \{ C_1, C_2 \}$,  $\mathcal{D}(2) = \{C_3, C_4, C_5\}$ and $\mathcal{D}(2) = \left\{ C_6 \right\}$, $\mathcal{D}(3) = \{ C_7, C_8, C_9\}$, etc.


\begin{equation}
    \mathcal{V}(k) = \left\{ \textnormal{validator set for dynasty $k$.  The accepted validators for checkpoints $\mathcal{D}(k)$.}\right\} \; .
\end{equation}


\begin{itemize}
\item We flip the emphasis of the proof statement from the traditional ``as long as $>\frac{2}{3}$ of validators are honest, there will be no safety failures'' to the contrapositive ``if there is a safety failure, then $\ge \frac{1}{3}$ of validators violated some protocol rule.''
\end{itemize}


\section{Full fork choice rule}

\begin{lstlisting}[language=Python, caption={Algorithm for determining the head of a forked chain}, captionpos=b, label={alg:forkchoice}]
from random import shuffle

def get_head(genesisblock):
    
    head = genesisblock
    
    while True:
        S = successors( head )
        
        if not S:
            return head

        # choose the successor with the greatest commits
        max_commit = max( map(valid_commits, S) )        
        S = [ s for s in S if valid_commits(S) == max_commit ]
        
        if len(S) == 1:
            head = S[0]
            continue

        # choose the succesor with the greatest prepares
        max_prepare = max( map(valid_prepares, S) )
        S = [ s for s in S if valid_prepares(S) == max_prepare ]
        
        if len(S) == 1:
            head = S[0]
            continue
        
        # choose the succesor with the greatest depth (longest chain)
        max_depth = max( map(depth, S) )
        S = [ s for s in S if depth(S) == max_depth ]
        
        if len(S) == 1:
            head = S[0]
            continue

        # choose a random successor
        shuffle(S)
        head = S.pop()

\end{lstlisting}



\section{Notes to Authors}
\subsection{Questions}
\begin{itemize}
\item If there are Prepares for the same hash+epoch pair from multiple sources, do they add?  Or do we simply take the max?
\item If checkpoint X is Justified, can it be Finalized without violating any Commandment?
\item In the fork-choice rule it remains ambiguous to me whether we're looking at the immediate successor or the whole lineage of successors.
\item \todo{fill me in!}
\end{itemize}


\subsection{Notes on Suggested Terminology}
\begin{itemize}
\item parent $\rightarrow$ predecessor.
\item child $\rightarrow$ successor (unless want to emphasize there can be multiple candidate successors)
\item ancestors $\rightarrow$ lineage
\item to refer to the set of $\{$ predecessor, successor $\}$ $\rightarrow$ adjacent
\end{itemize}
